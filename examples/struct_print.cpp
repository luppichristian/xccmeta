/**
 * @file print_struct.cpp
 * @brief Example: Generate struct printing functions using xccmeta
 *
 * This example demonstrates how to use xccmeta to:
 * 1. Parse C++ source code containing structs/classes
 * 2. Filter structs with a specific tag (e.g., @reflect)
 * 3. Generate print() functions for each struct that output field names and values
 *
 * Usage: xccmeta-example-print_struct
 *
 * The generated code will be written to "struct_print.generated.hpp"
 */

#include <iostream>
#include <string>
#include <xccmeta.hpp>

// Sample input source code with structs marked for reflection
constexpr const char* INPUT_SOURCE = R"(
/// @reflect
struct Person {
    std::string name;
    int age;
    double height;
    bool is_student;
};

/// @reflect
struct Point {
    double x;
    double y;
    double z;
};

/// @reflect
class Rectangle {
public:
    double width;
    double height;

    double area() const { return width * height; }
};

/// This struct is NOT tagged, so it will be ignored
struct InternalData {
    int secret_value;
    std::string hidden_info;
};

/// @reflect
struct Address {
    std::string street;
    std::string city;
    std::string country;
    int zip_code;
};
)";

int main() {
  std::cout << "=== xccmeta Struct Printer Generator Example ===" << std::endl;
  std::cout << std::endl;

  // Step 1: Set up compile arguments
  xccmeta::compile_args args;
  args.set_standard(xccmeta::language_standard::cxx20);

  // Step 2: Parse the input source code
  std::cout << "[1] Parsing source code..." << std::endl;
  xccmeta::parser parser;
  auto ast = parser.parse(INPUT_SOURCE, args);

  if (!ast) {
    std::cerr << "Error: Failed to parse input source code" << std::endl;
    return 1;
  }

  std::cout << "    Parsed successfully. AST root: " << ast->get_kind_name() << std::endl;

  // Debug: Print all children to see what was parsed
  std::cout << "    Children of AST root:" << std::endl;
  for (const auto& child : ast->get_children()) {
    std::cout << "      - " << child->get_kind_name() << ": " << child->get_name();
    if (!child->get_tags().empty()) {
      std::cout << " [tags:";
      for (const auto& tag : child->get_tags()) {
        std::cout << " @" << tag.get_name();
      }
      std::cout << "]";
    }
    std::cout << std::endl;
  }

  // Step 3: Find structs/classes with @reflect tag using node's find_descendants
  std::cout << "[2] Finding structs/classes with @reflect tag..." << std::endl;

  auto reflected_records = ast->find_descendants([](const xccmeta::node_ptr& n) {
    return (n->get_kind() == xccmeta::node::kind::struct_decl ||
            n->get_kind() == xccmeta::node::kind::class_decl) &&
           n->has_tag("reflect");
  });

  std::cout << "    Found " << reflected_records.size() << " record(s) with @reflect tag" << std::endl;

  // Step 4: Generate the output file
  std::cout << "[3] Generating struct_print.generated.hpp..." << std::endl;

  xccmeta::generator gen("build/struct_print.generated.hpp");

  // Header guard and includes
  gen.out("#pragma once");
  gen.out("");
  gen.out("#include <iostream>");
  gen.out("#include <string>");
  gen.out("");
  gen.out("// Auto-generated by xccmeta print_struct example");
  gen.out("// DO NOT EDIT MANUALLY");
  gen.out("");

  // Generate print functions for each struct/class
  for (const auto& record_node : reflected_records) {
    const std::string& record_name = record_node->get_name();
    auto fields = record_node->get_fields();

    gen.named_separator(record_name);
    gen.out("");

    // Generate print function
    gen.out("inline std::ostream& operator<<(std::ostream& os, const " + record_name + "& obj) {");
    gen.indent();
    gen.out("os << \"" + record_name + "{\";");
    gen.indent();

    for (size_t i = 0; i < fields.size(); ++i) {
      const auto& field = fields[i];
      const std::string& field_name = field->get_name();

      gen.out("os << \"" + field_name + "=\" << obj." + field_name);

      if (i < fields.size() - 1) {
        gen.out("    << \", \";");
      } else {
        gen.out("    << \"}\";");
      }
    }

    if (fields.empty()) {
      gen.out("os << \"}\";");
    }

    gen.unindent();
    gen.out("return os;");
    gen.unindent();
    gen.out("}");
    gen.out("");

    // Generate a convenience print function
    gen.out("inline void print_" + record_name + "(const " + record_name + "& obj) {");
    gen.indent();
    gen.out("std::cout << obj << std::endl;");
    gen.unindent();
    gen.out("}");
    gen.out("");

    std::cout << "    Generated print functions for: " << record_name
              << " (" << fields.size() << " fields)" << std::endl;
  }

  // Finalize the output
  if (!gen.done()) {
    std::cerr << "Error: Failed to write output file" << std::endl;
    return 1;
  }

  std::cout << std::endl;
  std::cout << "=== Generation Complete ===" << std::endl;
  std::cout << "Output: struct_print.generated.hpp" << std::endl;

  return 0;
}
