# Generator

The `generator` class provides utilities for writing generated code to output files with support for indentation, separators, and compile-time warnings.

## Header

```cpp
#include <xccmeta/xccmeta_generator.hpp>
```

## Overview

The generator is designed for producing code output files (like reflection data, serialization code, etc.) with:
- Line-by-line output with automatic newlines
- Indentation management
- Section separators
- Warning integration for compile-time feedback

## Constructor

```cpp
generator(const std::string& output_file);
```

Create a generator that writes to the specified output file.

```cpp
xccmeta::generator gen("output/generated.cpp");
```

## Destructor

```cpp
~generator();
```

Automatically closes the output file if not already done.

## Methods

### out

```cpp
generator& out(const std::string& data);
```

Output a line of data (automatically adds newline). Returns `*this` for chaining.

```cpp
gen.out("#include <string>")
   .out("")
   .out("namespace generated {");
```

### indent / unindent

```cpp
generator& indent();
generator& unindent();
```

Increase or decrease the indentation level. Returns `*this` for chaining.

```cpp
gen.out("struct Data {");
gen.indent();
gen.out("int value;");
gen.out("std::string name;");
gen.unindent();
gen.out("};");
```

**Output:**
```cpp
struct Data {
    int value;
    std::string name;
};
```

### separator

```cpp
generator& separator();
```

Output a separator line for visual organization.

```cpp
gen.out("// Section 1");
gen.separator();
gen.out("// Section 2");
```

### named_separator

```cpp
generator& named_separator(const std::string& name);
```

Output a named separator line.

```cpp
gen.named_separator("Type Registration");
```

**Output:**
```cpp
// ============ Type Registration ============
```

### warn

```cpp
generator& warn(const std::string& message, source_location loc = {});
generator& warn(const std::string& message, const node_ptr node);
```

Issue a custom warning message that will appear as a compiler warning when the generated file is compiled.

```cpp
gen.warn("This type has no fields", type_node);
gen.warn("Deprecated: use new API instead");
```

### done

```cpp
bool done();
```

Finalize generation, write warnings, and close the output file. Returns `true` on success.

```cpp
if (!gen.done()) {
    std::cerr << "Failed to write output file\n";
}
```

## Complete Example

```cpp
#include <xccmeta.hpp>
#include <iostream>

int main() {
    // Parse source code
    xccmeta::parser parser;
    auto ast = parser.parse(R"(
        namespace game {
            struct [[xccmeta::reflect]] Player {
                int id;
                float health;
                std::string name;
            };
            
            struct [[xccmeta::reflect]] Enemy {
                int id;
                int damage;
            };
        }
    )", xccmeta::compile_args::modern_cxx());
    
    // Find reflected types
    auto reflected = ast->find_descendants([](const auto& n) {
        return n->has_tag("xccmeta::reflect");
    });
    
    // Generate reflection code
    xccmeta::generator gen("generated/reflection.generated.cpp");
    
    // File header
    gen.out("// AUTO-GENERATED FILE - DO NOT EDIT");
    gen.out("// Generated by xccmeta reflection generator");
    gen.out("");
    gen.out("#include \"reflection.hpp\"");
    gen.out("#include <string>");
    gen.separator();
    
    gen.out("namespace generated {");
    gen.indent();
    gen.out("");
    
    // Generate type info for each reflected type
    for (const auto& type : reflected) {
        gen.named_separator(type->get_name());
        
        auto fields = type->get_fields();
        if (fields.empty()) {
            gen.warn("Type has no fields for reflection", type);
        }
        
        // Generate type registration
        gen.out("template<>");
        gen.out("struct TypeInfo<" + type->get_qualified_name() + "> {");
        gen.indent();
        
        gen.out("static constexpr const char* name = \"" + type->get_name() + "\";");
        gen.out("static constexpr size_t field_count = " + std::to_string(fields.size()) + ";");
        gen.out("");
        
        // Generate field info
        gen.out("static void for_each_field(auto&& visitor) {");
        gen.indent();
        
        for (const auto& field : fields) {
            gen.out("visitor(\"" + field->get_name() + "\", "
                   "&" + type->get_qualified_name() + "::" + field->get_name() + ");");
        }
        
        gen.unindent();
        gen.out("}");
        
        gen.unindent();
        gen.out("};");
        gen.out("");
    }
    
    // Generate registration function
    gen.separator();
    gen.out("void register_types() {");
    gen.indent();
    
    for (const auto& type : reflected) {
        gen.out("TypeRegistry::register_type<" + type->get_qualified_name() + ">();");
    }
    
    gen.unindent();
    gen.out("}");
    gen.out("");
    
    gen.unindent();
    gen.out("} // namespace generated");
    
    // Finalize
    if (gen.done()) {
        std::cout << "Generated reflection code successfully\n";
    } else {
        std::cerr << "Failed to generate output\n";
        return 1;
    }
    
    return 0;
}
```

**Generated output:**
```cpp
// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by xccmeta reflection generator

#include "reflection.hpp"
#include <string>
// ================================================

namespace generated {

// ============ Player ============
template<>
struct TypeInfo<game::Player> {
    static constexpr const char* name = "Player";
    static constexpr size_t field_count = 3;

    static void for_each_field(auto&& visitor) {
        visitor("id", &game::Player::id);
        visitor("health", &game::Player::health);
        visitor("name", &game::Player::name);
    }
};

// ============ Enemy ============
template<>
struct TypeInfo<game::Enemy> {
    static constexpr const char* name = "Enemy";
    static constexpr size_t field_count = 2;

    static void for_each_field(auto&& visitor) {
        visitor("id", &game::Enemy::id);
        visitor("damage", &game::Enemy::damage);
    }
};

// ================================================
void register_types() {
    TypeRegistry::register_type<game::Player>();
    TypeRegistry::register_type<game::Enemy>();
}

} // namespace generated
```

## Use Cases

### Reflection System Generator

```cpp
xccmeta::generator gen("reflection.generated.hpp");
gen.out("#pragma once");
gen.out("#include \"reflection_base.hpp\"");
// ... generate reflection macros/templates
gen.done();
```

### Serialization Code Generator

```cpp
xccmeta::generator gen("serialize.generated.cpp");
// ... generate serialization functions
gen.done();
```

### Binding Generator

```cpp
xccmeta::generator gen("bindings.generated.cpp");
// ... generate script bindings
gen.done();
```

## Tips

1. **Always call `done()`** - This ensures the file is properly closed and warnings are written.

2. **Use named separators** - They make generated code easier to navigate.

3. **Add warnings for edge cases** - They appear as compiler warnings, making issues visible during build.

4. **Include a "do not edit" header** - Prevents accidental manual edits to generated files.

5. **Use consistent indentation** - The `indent()`/`unindent()` methods help maintain readable output.

## See Also

- [Warnings](warnings.md) - Compile-time warning generation
- [Node](node.md) - Extracting metadata for code generation
- [Filter](filter.md) - Collecting nodes for generation
