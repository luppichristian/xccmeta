/**
 * @file binary_read_write.cpp
 * @brief Example: Generate binary serialization functions using xccmeta
 *
 * This example demonstrates how to use xccmeta to:
 * 1. Parse C++ source code containing structs
 * 2. Filter structs with a specific tag (e.g., @reflect)
 * 3. Generate endian-agnostic binary read/write functions for struct members
 *
 * Usage: xccmeta-example-binary_read_write
 *
 * The generated code will be written to "binary_serialization.generated.hpp"
 */

#include <cstdint>
#include <cstring>
#include <iostream>
#include <string>
#include <vector>
#include <xccmeta.hpp>

// Sample input source code with structs marked for reflection
constexpr const char* INPUT_SOURCE = R"(
/// @reflect
struct PlayerData {
    std::string name;
    int32_t level;
    float health;
    double experience;
    bool is_alive;
    uint16_t score;
};

/// @reflect
struct GameState {
    int64_t timestamp;
    float game_time;
    uint32_t player_count;
    std::string map_name;
    bool paused;
};
)";

int main() {
  std::cout << "=== xccmeta Binary Read/Write Generator Example ===" << std::endl;
  std::cout << std::endl;

  // Step 1: Set up compile arguments
  xccmeta::compile_args args;
  args.set_standard(xccmeta::language_standard::cxx20);

  // Step 2: Parse the input source code
  std::cout << "[1] Parsing source code..." << std::endl;
  xccmeta::parser parser;
  auto ast = parser.parse(INPUT_SOURCE, args);

  if (!ast) {
    std::cerr << "Error: Failed to parse input source code" << std::endl;
    return 1;
  }

  std::cout << "    Parsed successfully. AST root: " << ast->get_kind_name() << std::endl;

  // Step 3: Find structs with @reflect tag
  std::cout << "[2] Finding structs with @reflect tag..." << std::endl;

  auto reflected_structs = ast->find_descendants([](const xccmeta::node_ptr& n) {
    return n->get_kind() == xccmeta::node::kind::struct_decl && n->has_tag("reflect");
  });

  std::cout << "    Found " << reflected_structs.size() << " struct(s) with @reflect tag" << std::endl;

  // Step 4: Generate the output file
  std::cout << "[3] Generating binary_serialization.generated.hpp..." << std::endl;

  xccmeta::generator gen("build/binary_serialization.generated.hpp");

  // Header guard and includes
  gen.out("#pragma once");
  gen.out("");
  gen.out("#include <iostream>");
  gen.out("#include <fstream>");
  gen.out("#include <string>");
  gen.out("#include <vector>");
  gen.out("#include <cstdint>");
  gen.out("#include <cstring>");
  gen.out("#ifdef _WIN32");
  gen.out("#include <winsock2.h>");
  gen.out("#else");
  gen.out("#include <arpa/inet.h>  // For endian conversion functions");
  gen.out("#endif");
  gen.out("");
  gen.out("// Auto-generated by xccmeta binary_read_write example");
  gen.out("// DO NOT EDIT MANUALLY");
  gen.out("");
  gen.out("// Endian-agnostic binary serialization utilities");
  gen.out("namespace binary {");
  gen.out("");

  // Generate utility functions
  gen.out("// Utility functions for endian-safe I/O");
  gen.out("inline uint64_t htonll_custom(uint64_t value) {");
  gen.indent();
  gen.out("#ifdef _WIN32");
  gen.out("return htonll(value);");
  gen.out("#else");
  gen.out("return ((uint64_t)htonl(value & 0xFFFFFFFF) << 32) | htonl(value >> 32);");
  gen.out("#endif");
  gen.unindent();
  gen.out("}");
  gen.out("");
  gen.out("inline uint64_t ntohll_custom(uint64_t value) {");
  gen.indent();
  gen.out("#ifdef _WIN32");
  gen.out("return ntohll(value);");
  gen.out("#else");
  gen.out("return ((uint64_t)ntohl(value & 0xFFFFFFFF) << 32) | ntohl(value >> 32);");
  gen.out("#endif");
  gen.unindent();
  gen.out("}");
  gen.out("");
  gen.out("template<typename T>");
  gen.out("void write_integral(std::ostream& os, T value) {");
  gen.indent();
  gen.out("static_assert(std::is_integral_v<T>, \"T must be an integral type\");");
  gen.out("");
  gen.out("if constexpr (sizeof(T) == 1) {");
  gen.indent();
  gen.out("os.write(reinterpret_cast<const char*>(&value), sizeof(T));");
  gen.unindent();
  gen.out("} else {");
  gen.indent();
  gen.out("// Convert to network byte order (big-endian)");
  gen.out("T net_value;");
  gen.out("if constexpr (sizeof(T) == 2) {");
  gen.indent();
  gen.out("net_value = htons(static_cast<uint16_t>(value));");
  gen.unindent();
  gen.out("} else if constexpr (sizeof(T) == 4) {");
  gen.indent();
  gen.out("net_value = htonl(static_cast<uint32_t>(value));");
  gen.unindent();
  gen.out("} else if constexpr (sizeof(T) == 8) {");
  gen.indent();
  gen.out("net_value = htonll_custom(static_cast<uint64_t>(value));");
  gen.unindent();
  gen.out("}");
  gen.out("os.write(reinterpret_cast<const char*>(&net_value), sizeof(T));");
  gen.unindent();
  gen.out("}");
  gen.unindent();
  gen.out("}");
  gen.out("");

  gen.out("template<typename T>");
  gen.out("T read_integral(std::istream& is) {");
  gen.indent();
  gen.out("static_assert(std::is_integral_v<T>, \"T must be an integral type\");");
  gen.out("");
  gen.out("T net_value;");
  gen.out("is.read(reinterpret_cast<char*>(&net_value), sizeof(T));");
  gen.out("");
  gen.out("if constexpr (sizeof(T) == 1) {");
  gen.indent();
  gen.out("return net_value;");
  gen.unindent();
  gen.out("} else {");
  gen.out("// Convert from network byte order (big-endian)");
  gen.out("if constexpr (sizeof(T) == 2) {");
  gen.indent();
  gen.out("return static_cast<T>(ntohs(static_cast<uint16_t>(net_value)));");
  gen.unindent();
  gen.out("} else if constexpr (sizeof(T) == 4) {");
  gen.indent();
  gen.out("return static_cast<T>(ntohl(static_cast<uint32_t>(net_value)));");
  gen.unindent();
  gen.out("} else if constexpr (sizeof(T) == 8) {");
  gen.indent();
  gen.out("return static_cast<T>(ntohll_custom(static_cast<uint64_t>(net_value)));");
  gen.unindent();
  gen.out("}");
  gen.out("}");
  gen.unindent();
  gen.out("}");
  gen.out("");

  gen.out("inline void write_string(std::ostream& os, const std::string& str) {");
  gen.indent();
  gen.out("uint32_t length = static_cast<uint32_t>(str.size());");
  gen.out("write_integral(os, length);");
  gen.out("os.write(str.data(), length);");
  gen.unindent();
  gen.out("}");
  gen.out("");

  gen.out("inline std::string read_string(std::istream& is) {");
  gen.indent();
  gen.out("uint32_t length = read_integral<uint32_t>(is);");
  gen.out("std::string result(length, '\\0');");
  gen.out("is.read(result.data(), length);");
  gen.out("return result;");
  gen.unindent();
  gen.out("}");
  gen.out("");

  gen.out("inline void write_bool(std::ostream& os, bool value) {");
  gen.indent();
  gen.out("uint8_t byte_value = value ? 1 : 0;");
  gen.out("os.write(reinterpret_cast<const char*>(&byte_value), sizeof(uint8_t));");
  gen.unindent();
  gen.out("}");
  gen.out("");

  gen.out("inline bool read_bool(std::istream& is) {");
  gen.indent();
  gen.out("uint8_t byte_value;");
  gen.out("is.read(reinterpret_cast<char*>(&byte_value), sizeof(uint8_t));");
  gen.out("return byte_value != 0;");
  gen.unindent();
  gen.out("}");
  gen.out("");

  // Generate serialization functions for each struct
  for (const auto& struct_node : reflected_structs) {
    const std::string& struct_name = struct_node->get_name();
    auto fields = struct_node->get_fields();

    gen.named_separator(struct_name);
    gen.out("");

    // Generate write function
    gen.out("inline void write_" + struct_name + "(std::ostream& os, const " + struct_name + "& obj) {");
    gen.indent();

    for (const auto& field : fields) {
      const std::string& field_name = field->get_name();
      const std::string& field_type = field->get_type().get_spelling();

      if (field_type == "std::string") {
        gen.out("write_string(os, obj." + field_name + ");");
      } else if (field_type == "bool") {
        gen.out("write_bool(os, obj." + field_name + ");");
      } else if (field->get_type().is_integral()) {
        gen.out("write_integral(os, obj." + field_name + ");");
      } else if (field->get_type().is_floating_point()) {
        // For floating point, we need to handle endianness carefully
        gen.out("// Note: Floating point endian conversion");
        gen.out("static_assert(sizeof(" + field_type + ") == " + std::to_string(field->get_type().get_size_bytes()) + ", \"Unexpected float size\");");
        gen.out("union { " + field_type + " f; uint" + std::to_string(field->get_type().get_size_bytes() * 8) + "_t i; } converter;");
        gen.out("converter.f = obj." + field_name + ";");
        gen.out("write_integral(os, converter.i);");
      } else {
        gen.out("// Unsupported type: " + field_type + " for field " + field_name);
      }
    }

    gen.unindent();
    gen.out("}");
    gen.out("");

    // Generate read function
    gen.out("inline void read_" + struct_name + "(std::istream& is, " + struct_name + "& obj) {");
    gen.indent();

    for (const auto& field : fields) {
      const std::string& field_name = field->get_name();
      const std::string& field_type = field->get_type().get_spelling();

      if (field_type == "std::string") {
        gen.out("obj." + field_name + " = read_string(is);");
      } else if (field_type == "bool") {
        gen.out("obj." + field_name + " = read_bool(is);");
      } else if (field->get_type().is_integral()) {
        gen.out("obj." + field_name + " = read_integral<" + field_type + ">(is);");
      } else if (field->get_type().is_floating_point()) {
        gen.out("// Note: Floating point endian conversion");
        gen.out("union { " + field_type + " f; uint" + std::to_string(field->get_type().get_size_bytes() * 8) + "_t i; } converter;");
        gen.out("converter.i = read_integral<uint" + std::to_string(field->get_type().get_size_bytes() * 8) + "_t>(is);");
        gen.out("obj." + field_name + " = converter.f;");
      } else {
        gen.out("// Unsupported type: " + field_type + " for field " + field_name);
      }
    }

    gen.unindent();
    gen.out("}");
    gen.out("");

    // Generate convenience functions
    gen.out("inline bool save_" + struct_name + "_to_file(const std::string& filename, const " + struct_name + "& obj) {");
    gen.indent();
    gen.out("std::ofstream file(filename, std::ios::binary);");
    gen.out("if (!file) return false;");
    gen.out("write_" + struct_name + "(file, obj);");
    gen.out("return file.good();");
    gen.unindent();
    gen.out("}");
    gen.out("");

    gen.out("inline bool load_" + struct_name + "_from_file(const std::string& filename, " + struct_name + "& obj) {");
    gen.indent();
    gen.out("std::ifstream file(filename, std::ios::binary);");
    gen.out("if (!file) return false;");
    gen.out("read_" + struct_name + "(file, obj);");
    gen.out("return file.good();");
    gen.unindent();
    gen.out("}");
    gen.out("");

    std::cout << "    Generated binary I/O functions for: " << struct_name
              << " (" << fields.size() << " fields)" << std::endl;
  }

  gen.out("} // namespace binary");
  gen.out("");

  // Finalize the output
  if (!gen.done()) {
    std::cerr << "Error: Failed to write output file" << std::endl;
    return 1;
  }

  std::cout << std::endl;
  std::cout << "=== Generation Complete ===" << std::endl;
  std::cout << "Output: binary_serialization.generated.hpp" << std::endl;
  std::cout << std::endl;
  std::cout << "Note: This example generates endian-agnostic binary serialization." << std::endl;
  std::cout << "All multi-byte values are converted to network byte order (big-endian)." << std::endl;

  return 0;
}
