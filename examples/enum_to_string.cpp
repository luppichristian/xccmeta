/**
 * @file enum_to_string.cpp
 * @brief Example: Generate enum-to-string conversion functions using xccmeta
 *
 * This example demonstrates how to use xccmeta to:
 * 1. Parse C++ source code containing enums
 * 2. Filter enums with a specific tag (e.g., @reflect)
 * 3. Generate to_string() and from_string() functions for each enum
 *
 * Usage: xccmeta-example-enum_to_string
 *
 * The generated code will be written to "enum_strings.generated.hpp"
 */

#include <iostream>
#include <string>
#include <xccmeta.hpp>

// Sample input source code with enums marked for reflection
constexpr const char* INPUT_SOURCE = R"(
/// @reflect
enum class Color {
    Red,
    Green,
    Blue,
    Yellow,
    Cyan,
    Magenta
};

/// @reflect
enum class LogLevel {
    Debug = 0,
    Info = 1,
    Warning = 2,
    Error = 3,
    Critical = 4
};

/// This enum is NOT tagged, so it will be ignored
enum class InternalState {
    Idle,
    Processing,
    Done
};

/// @reflect
/// @flags
enum class Permissions : unsigned int {
    None = 0,
    Read = 1,
    Write = 2,
    Execute = 4,
    All = 7
};
)";

int main() {
  std::cout << "=== xccmeta Enum-to-String Generator Example ===" << std::endl;
  std::cout << std::endl;

  // Step 1: Set up compile arguments
  xccmeta::compile_args args;
  args.set_standard(xccmeta::language_standard::cxx20);

  // Step 2: Parse the input source code
  std::cout << "[1] Parsing source code..." << std::endl;
  xccmeta::parser parser;
  auto ast = parser.parse(INPUT_SOURCE, args);

  if (!ast) {
    std::cerr << "Error: Failed to parse input source code" << std::endl;
    return 1;
  }

  std::cout << "    Parsed successfully. AST root: " << ast->get_kind_name() << std::endl;

  // Debug: Print all children to see what was parsed
  std::cout << "    Children of AST root:" << std::endl;
  for (const auto& child : ast->get_children()) {
    std::cout << "      - " << child->get_kind_name() << ": " << child->get_name();
    if (!child->get_tags().empty()) {
      std::cout << " [tags:";
      for (const auto& tag : child->get_tags()) {
        std::cout << " @" << tag.get_name();
      }
      std::cout << "]";
    }
    std::cout << std::endl;
  }

  // Step 3: Find enums with @reflect tag using node's find_descendants
  std::cout << "[2] Finding enums with @reflect tag..." << std::endl;

  auto reflected_enums = ast->find_descendants([](const xccmeta::node_ptr& n) {
    return n->get_kind() == xccmeta::node::kind::enum_decl && n->has_tag("reflect");
  });

  std::cout << "    Found " << reflected_enums.size() << " enum(s) with @reflect tag" << std::endl;

  // Step 4: Generate the output file
  std::cout << "[3] Generating enum_strings.generated.hpp..." << std::endl;

  xccmeta::generator gen("build/enum_strings.generated.hpp");

  // Header guard and includes
  gen.out("#pragma once");
  gen.out("");
  gen.out("#include <string>");
  gen.out("#include <string_view>");
  gen.out("#include <optional>");
  gen.out("#include <stdexcept>");
  gen.out("");
  gen.out("// Auto-generated by xccmeta enum_to_string example");
  gen.out("// DO NOT EDIT MANUALLY");
  gen.out("");

  // Generate functions for each enum
  for (const auto& enum_node : reflected_enums) {
    const std::string& enum_name = enum_node->get_name();
    auto constants = enum_node->get_enum_constants();
    bool is_scoped = enum_node->is_scoped_enum();
    bool is_flags = enum_node->has_tag("flags");

    gen.named_separator(enum_name);
    gen.out("");

    // Check if it has the @flags tag
    if (is_flags) {
      gen.out("// Note: " + enum_name + " is marked as @flags (bitmask enum)");
    }

    // Generate to_string function
    gen.out("inline constexpr std::string_view to_string(" + enum_name + " value) {");
    gen.indent();
    gen.out("switch (value) {");
    gen.indent();

    for (const auto& constant : constants) {
      std::string full_name = is_scoped
                                  ? enum_name + "::" + constant->get_name()
                                  : constant->get_name();
      gen.out("case " + full_name + ": return \"" + constant->get_name() + "\";");
    }

    gen.out("default: return \"<unknown>\";");
    gen.unindent();
    gen.out("}");
    gen.unindent();
    gen.out("}");
    gen.out("");

    // Generate from_string function
    gen.out("inline std::optional<" + enum_name + "> " + enum_name + "_from_string(std::string_view str) {");
    gen.indent();

    for (const auto& constant : constants) {
      std::string full_name = is_scoped
                                  ? enum_name + "::" + constant->get_name()
                                  : constant->get_name();
      gen.out("if (str == \"" + constant->get_name() + "\") return " + full_name + ";");
    }

    gen.out("return std::nullopt;");
    gen.unindent();
    gen.out("}");
    gen.out("");

    // Generate ostream operator
    gen.out("inline std::ostream& operator<<(std::ostream& os, " + enum_name + " value) {");
    gen.indent();
    gen.out("return os << to_string(value);");
    gen.unindent();
    gen.out("}");
    gen.out("");

    std::cout << "    Generated functions for: " << enum_name
              << " (" << constants.size() << " constants)" << std::endl;
  }

  // Finalize the output
  if (!gen.done()) {
    std::cerr << "Error: Failed to write output file" << std::endl;
    return 1;
  }

  std::cout << std::endl;
  std::cout << "=== Generation Complete ===" << std::endl;
  std::cout << "Output: enum_strings.generated.hpp" << std::endl;

  return 0;
}
